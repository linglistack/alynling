library(GeoLift)
inject_lift_for_given_market <- function(x, market_ID){
# Taken from plot.GeoLiftPower
# Takes a GeoLiftMarketSelection object, and a market_ID, returns:
# 1. a GeoLift output object for market selection treatment vs. control
# 2. a data frame containing effect size, power, and Investment needed.
Market <- x$BestMarkets %>% dplyr::filter(ID == market_ID)
locs_aux <- unlist(strsplit(stringr::str_replace_all(Market$location, ", ", ","), split = ","))
max_time <- max(x$parameters$data$time)
data_lifted <- x$parameters$data
data_lifted$Y[data_lifted$location %in% locs_aux &
data_lifted$time >= max_time - Market$duration + 1] <-
data_lifted$Y[data_lifted$location %in% locs_aux &
data_lifted$time >= max_time - Market$duration + 1] * (1 + Market$EffectSize)
if (tolower(x$parameters$side_of_test) == "two_sided") {
stat_test <- "Total"
} else {
if (Market$EffectSize < 0) {
stat_test <- "Negative"
} else if (Market$EffectSize > 0) {
stat_test <- "Positive"
}
}
artificial_lift <- GeoLift(
Y_id = "Y",
time_id = "time",
location_id = "location",
data = data_lifted,
locations = locs_aux,
treatment_start_time = max_time - Market$duration + 1,
treatment_end_time = max_time,
model = x$parameters$model,
fixed_effects = x$parameters$fixed_effects,
stat_test = stat_test
)
treatment_periods <- unique(x$duration)
EffectSize <- unique(x$EffectSize)
PowerPlot_data <- as.data.frame(x$PowerCurves %>% dplyr::filter(
duration == Market$duration,
location == Market$location
))%>%
dplyr::group_by(EffectSize) %>%
dplyr::summarise(power = mean(power), investment = mean(Investment))
return(list("lifted" = artificial_lift, "power" = PowerPlot_data))
}
GeoLift_lift_data <- function(GeoLift) {
# Taken from Lift.plot
# Takes a GeoLift object, returns:
# treatment + observation + confidence band for treatment period
treatment_obs <- as.data.frame(
colMeans(
matrix(
GeoLift$y_obs,
nrow = nrow(GeoLift$test_id),
ncol = GeoLift$TreatmentEnd
)
)
) * nrow(GeoLift$test_id)
colnames(treatment_obs) <- c("t_obs")
q_treatment_locations <- length(GeoLift$test_id$name)
df <- data.frame(
t_obs = treatment_obs$t_obs,
c_obs = GeoLift$y_hat * q_treatment_locations,
c_obs_lower_bound = (GeoLift$y_hat - (GeoLift$summary$att$Estimate - GeoLift$summary$att$lower_bound)) * q_treatment_locations,
c_obs_upper_bound = (GeoLift$y_hat + (GeoLift$summary$att$upper_bound - GeoLift$summary$att$Estimate)) * q_treatment_locations,
Time = 1:length(treatment_obs$t_obs)
)
return(df)
}
GeoLift_att_data <- function(GeoLift) {
# Taken from absolute_value.plot
# Takes a GeoLift object, returns:
# time + ATT estimate and confidence band for the treatment period
# Keep only needed columns from ATT summary
df <- GeoLift$summary$att[, c("Time", "Estimate", "lower_bound", "upper_bound")]
return(df)
}
library(GeoLift)
GeoLift_lift_injection <- function(x, market_ID){
# Taken from plot.GeoLiftPower
# Takes a GeoLiftMarketSelection object, and a market_ID, returns:
# 1. a GeoLift output object for market selection treatment vs. control
# 2. a data frame containing effect size, power, and Investment needed.
Market <- x$BestMarkets %>% dplyr::filter(ID == market_ID)
locs_aux <- unlist(strsplit(stringr::str_replace_all(Market$location, ", ", ","), split = ","))
max_time <- max(x$parameters$data$time)
data_lifted <- x$parameters$data
data_lifted$Y[data_lifted$location %in% locs_aux &
data_lifted$time >= max_time - Market$duration + 1] <-
data_lifted$Y[data_lifted$location %in% locs_aux &
data_lifted$time >= max_time - Market$duration + 1] * (1 + Market$EffectSize)
if (tolower(x$parameters$side_of_test) == "two_sided") {
stat_test <- "Total"
} else {
if (Market$EffectSize < 0) {
stat_test <- "Negative"
} else if (Market$EffectSize > 0) {
stat_test <- "Positive"
}
}
artificial_lift <- GeoLift(
Y_id = "Y",
time_id = "time",
location_id = "location",
data = data_lifted,
locations = locs_aux,
treatment_start_time = max_time - Market$duration + 1,
treatment_end_time = max_time,
model = x$parameters$model,
fixed_effects = x$parameters$fixed_effects,
stat_test = stat_test
)
treatment_periods <- unique(x$duration)
EffectSize <- unique(x$EffectSize)
PowerPlot_data <- as.data.frame(x$PowerCurves %>% dplyr::filter(
duration == Market$duration,
location == Market$location
))%>%
dplyr::group_by(EffectSize) %>%
dplyr::summarise(power = mean(power), investment = mean(Investment))
return(list("lifted" = artificial_lift, "power" = PowerPlot_data))
}
GeoLift_lift_data <- function(GeoLift) {
# Taken from Lift.plot
# Takes a GeoLift object, returns:
# treatment + observation + confidence band for treatment period
treatment_obs <- as.data.frame(
colMeans(
matrix(
GeoLift$y_obs,
nrow = nrow(GeoLift$test_id),
ncol = GeoLift$TreatmentEnd
)
)
) * nrow(GeoLift$test_id)
colnames(treatment_obs) <- c("t_obs")
q_treatment_locations <- length(GeoLift$test_id$name)
df <- data.frame(
t_obs = treatment_obs$t_obs,
c_obs = GeoLift$y_hat * q_treatment_locations,
c_obs_lower_bound = (GeoLift$y_hat - (GeoLift$summary$att$Estimate - GeoLift$summary$att$lower_bound)) * q_treatment_locations,
c_obs_upper_bound = (GeoLift$y_hat + (GeoLift$summary$att$upper_bound - GeoLift$summary$att$Estimate)) * q_treatment_locations,
Time = 1:length(treatment_obs$t_obs)
)
return(df)
}
GeoLift_att_data <- function(GeoLift) {
# Taken from absolute_value.plot
# Takes a GeoLift object, returns:
# time + ATT estimate and confidence band for the treatment period
# Keep only needed columns from ATT summary
df <- GeoLift$summary$att[, c("Time", "Estimate", "lower_bound", "upper_bound")]
return(df)
}
library(GeoLift)
GeoLift_lift_injection <- function(market_selection, market_ID){
# Taken from plot.GeoLiftPower
# Takes a GeoLiftMarketSelection object, and a market_ID, returns:
# 1. a GeoLift output object for market selection treatment vs. control
# 2. a data frame containing effect size, power, and Investment needed.
Market <- market_selection$BestMarkets %>% dplyr::filter(ID == market_ID)
locs_aux <- unlist(strsplit(stringr::str_replace_all(Market$location, ", ", ","), split = ","))
max_time <- max(market_selection$parameters$data$time)
data_lifted <- market_selection$parameters$data
data_lifted$Y[data_lifted$location %in% locs_aux &
data_lifted$time >= max_time - Market$duration + 1] <-
data_lifted$Y[data_lifted$location %in% locs_aux &
data_lifted$time >= max_time - Market$duration + 1] * (1 + Market$EffectSize)
if (tolower(market_selection$parameters$side_of_test) == "two_sided") {
stat_test <- "Total"
} else {
if (Market$EffectSize < 0) {
stat_test <- "Negative"
} else if (Market$EffectSize > 0) {
stat_test <- "Positive"
}
}
artificial_lift <- GeoLift(
Y_id = "Y",
time_id = "time",
location_id = "location",
data = data_lifted,
locations = locs_aux,
treatment_start_time = max_time - Market$duration + 1,
treatment_end_time = max_time,
model = market_selection$parameters$model,
fixed_effects = market_selection$parameters$fixed_effects,
stat_test = stat_test
)
treatment_periods <- unique(market_selection$duration)
EffectSize <- unique(market_selection$EffectSize)
PowerPlot_data <- as.data.frame(market_selection$PowerCurves %>% dplyr::filter(
duration == Market$duration,
location == Market$location
))%>%
dplyr::group_by(EffectSize) %>%
dplyr::summarise(power = mean(power), investment = mean(Investment))
return(list("lifted" = artificial_lift, "power" = PowerPlot_data))
}
GeoLift_lift_data <- function(GeoLift) {
# Taken from Lift.plot
# Takes a GeoLift object, returns:
# treatment + observation + confidence band for treatment period
treatment_obs <- as.data.frame(
colMeans(
matrix(
GeoLift$y_obs,
nrow = nrow(GeoLift$test_id),
ncol = GeoLift$TreatmentEnd
)
)
) * nrow(GeoLift$test_id)
colnames(treatment_obs) <- c("t_obs")
q_treatment_locations <- length(GeoLift$test_id$name)
df <- data.frame(
t_obs = treatment_obs$t_obs,
c_obs = GeoLift$y_hat * q_treatment_locations,
c_obs_lower_bound = (GeoLift$y_hat - (GeoLift$summary$att$Estimate - GeoLift$summary$att$lower_bound)) * q_treatment_locations,
c_obs_upper_bound = (GeoLift$y_hat + (GeoLift$summary$att$upper_bound - GeoLift$summary$att$Estimate)) * q_treatment_locations,
Time = 1:length(treatment_obs$t_obs)
)
return(df)
}
GeoLift_att_data <- function(GeoLift) {
# Taken from absolute_value.plot
# Takes a GeoLift object, returns:
# time + ATT estimate and confidence band for the treatment period
# Keep only needed columns from ATT summary
df <- GeoLift$summary$att[, c("Time", "Estimate", "lower_bound", "upper_bound")]
return(df)
}
library(GeoLift)
library(tidyverse)
# Plots for MarketSelections ----------------------------------------------
data(GeoLift_PreTest)
GeoTestData_PreTest <- GeoDataRead(data = GeoLift_PreTest,
date_id = "date",
location_id = "location",
Y_id = "Y",
X = c(), #empty list as we have no covariates
format = "yyyy-mm-dd",
summary = TRUE)
MarketSelections <- GeoLiftMarketSelection(data = GeoTestData_PreTest,
treatment_periods = c(10,15),
N = c(2,3,4,5),
Y_id = "Y",
location_id = "location",
time_id = "time",
effect_size = seq(0, 0.5, 0.05),
lookback_window = 1,
include_markets = c("chicago"),
exclude_markets = c("honolulu"),
holdout = c(0.5, 1),
cpic = 7.50,
budget = 100000,
alpha = 0.1,
Correlations = TRUE,
fixed_effects = TRUE,
side_of_test = "two_sided")
ID = 3
artificial_lift <- GeoLift_lift_injection(MarketSelections, ID)
AL_lifted <- artificial_lift$lifted
AL_power <- artificial_lift$power
AL_power %>% ggplot() +
geom_line(aes(x = EffectSize, y = power))
plot(MarketSelections, ID)
AL_lifted %>% as_tibble()
AL_lifted
GeoLift_lift_data(AL_lifted)
GeoLift_att_data(AL_lifted)
library(GeoLift)
library(tidyverse)
# Plots for MarketSelections ----------------------------------------------
data(GeoLift_PreTest)
GeoTestData_PreTest <- GeoDataRead(data = GeoLift_PreTest,
date_id = "date",
location_id = "location",
Y_id = "Y",
X = c(), #empty list as we have no covariates
format = "yyyy-mm-dd",
summary = TRUE)
MarketSelections <- GeoLiftMarketSelection(data = GeoTestData_PreTest,
treatment_periods = c(10,15),
N = c(2,3,4,5),
Y_id = "Y",
location_id = "location",
time_id = "time",
effect_size = seq(0, 0.5, 0.05),
lookback_window = 1,
include_markets = c("chicago"),
exclude_markets = c("honolulu"),
holdout = c(0.5, 1),
cpic = 7.50,
budget = 100000,
alpha = 0.1,
Correlations = TRUE,
fixed_effects = TRUE,
side_of_test = "two_sided")
getwd()
setwd("./GitHub/alynling")
getwd()
setwd("./api")
getwd()
source(file.path("plot_helper.R"))
library(GeoLift)
library(tidyverse)
library(GeoLift)
library(tidyverse)
setwd("/home/shiwen/GitHub/alynling/api")
source(file.path("plot_helper.R"))
data(GeoLift_PreTest)
GeoTestData_PreTest <- GeoDataRead(data = GeoLift_PreTest,
date_id = "date",
location_id = "location",
Y_id = "Y",
X = c(), #empty list as we have no covariates
format = "yyyy-mm-dd",
summary = TRUE)
MarketSelections <- GeoLiftMarketSelection(data = GeoTestData_PreTest,
treatment_periods = c(10,15),
N = c(2,3,4,5),
Y_id = "Y",
location_id = "location",
time_id = "time",
effect_size = seq(0, 0.5, 0.05),
lookback_window = 1,
include_markets = c("chicago"),
exclude_markets = c("honolulu"),
holdout = c(0.5, 1),
cpic = 7.50,
budget = 100000,
alpha = 0.1,
Correlations = TRUE,
fixed_effects = TRUE,
side_of_test = "two_sided")
ID = 3
artificial_lift <- GeoLift_lift_injection(MarketSelections, ID)
AL_lifted <- artificial_lift$lifted
AL_power <- artificial_lift$power
AL_power %>% ggplot() +
geom_line(aes(x = EffectSize, y = power))
GeoLift_lift_data(AL_lifted)
AL_power
GeoLift_att_data(AL_lifted)
library(GeoLift)
library(tidyverse)
data(GeoLift_PreTest)
# Read into GeoLifts format with GeoDataRead
GeoTestData_PreTest <- GeoDataRead(data = GeoLift_PreTest,
date_id = "date",
location_id = "location",
Y_id = "Y",
X = c(), #empty list as we have no covariates
format = "yyyy-mm-dd",
summary = TRUE)
# Plot the KPI's historical values
GeoPlot(GeoTestData_PreTest)
set.seed(8) #To replicate the results
Markets <- MultiCellMarketSelection(data = GeoTestData_PreTest,
k = 2,
sampling_method = "systematic",
top_choices = 10,
N = c(2,3),
effect_size = seq(0, 0.25, 0.025),
treatment_periods = c(15),
lookback_window = 1,
cpic = c(7, 7.50),
alpha = 0.1,
model = "None",
fixed_effects = TRUE,
Correlations = TRUE,
side_of_test = "one_sided")
Markets
# Cell and Market IDs in a list
test_locs <- list(cell_1 = 1, #chicago, cincinnati
cell_2 = 3) #honolulu, indianapolis
test_locs
plot(Markets,
test_markets = test_locs,
type = "Lift",
stacked = TRUE)
Power <- MultiCellPower(Markets,
test_markets = test_locs,
effect_size =  seq(-0.5, 0.5, 0.05),
lookback_window = 7)
plot(Power,
actual_values = TRUE,
smoothed_values = FALSE,
show_mde = TRUE,
breaks_x_axis = 15,
stacked = TRUE)
Winners <- MultiCellWinner(Power,
effect_size = 0.1,
geolift_type = "standard",
ROAS = seq(1,10,0.5),
alpha = 0.1,
method = "conformal",
stat_test = "Positive"
)
Winners
data(GeoLift_Test_MultiCell)
# Read test data
GeoTestData_Test <- GeoDataRead(data = GeoLift_Test_MultiCell,
date_id = "date",
location_id = "location",
Y_id = "Y",
X = c(), #empty list as we have no covariates
format = "yyyy-mm-dd",
summary = TRUE)
# First we specify our test locations as a list
test_locations <- list(cell_1 = list("chicago", "cincinnati"),
cell_2 = list("honolulu", "indianapolis"))
#Then, we run MultiCellResults
MultiCellResults <- GeoLiftMultiCell(data = GeoTestData_Test,
locations = test_locations,
treatment_start_time = 91,
treatment_end_time = 105,
alpha = 0.1,
model = "best",
fixed_effects = TRUE,
ConfidenceIntervals = TRUE,
method = "conformal",
stat_test = "Positive",
winner_declaration = TRUE)
plot(MultiCellResults, type = "Lift", stacked = TRUE)
plot(MultiCellResults, type = "ATT", stacked = TRUE)
set.seed(8) #To replicate the results
Markets <- MultiCellMarketSelection(data = GeoTestData_PreTest,
k = 1,
sampling_method = "systematic",
top_choices = 10,
N = c(2,3),
effect_size = seq(0, 0.25, 0.025),
treatment_periods = c(15),
lookback_window = 1,
cpic = c(7, 7.50),
alpha = 0.1,
model = "None",
fixed_effects = TRUE,
Correlations = TRUE,
side_of_test = "one_sided")
Markets <- MultiCellMarketSelection(data = GeoTestData_PreTest,
k = 1,
sampling_method = "systematic",
top_choices = 10,
N = c(2,3),
effect_size = seq(0, 0.25, 0.025),
treatment_periods = c(15),
lookback_window = 1,
cpic = c(1),
alpha = 0.1,
model = "None",
fixed_effects = TRUE,
Correlations = TRUE,
side_of_test = "one_sided")
Markets
GeoLiftMarketSelection(data = GeoTestData_PreTest,
treatment_periods = c(15),
N = c(2,3),
Y_id = "Y",
location_id = "location",
time_id = "time",
effect_size = seq(0, 0.25, 0.05),
lookback_window = 1,
include_markets = c("chicago"),
exclude_markets = c("honolulu"),
holdout = c(0.5, 1),
cpic = 1,
budget = 100000,
alpha = 0.1,
Correlations = TRUE,
fixed_effects = TRUE,
side_of_test = "one_sided")
temp <- GeoLiftMarketSelection(data = GeoTestData_PreTest,
treatment_periods = c(15),
N = c(2,3),
Y_id = "Y",
location_id = "location",
time_id = "time",
effect_size = seq(0, 0.25, 0.05),
lookback_window = 1,
include_markets = c("chicago"),
exclude_markets = c("honolulu"),
holdout = c(0.5, 1),
cpic = 1,
budget = 100000,
alpha = 0.1,
Correlations = TRUE,
fixed_effects = TRUE,
side_of_test = "one_sided")
temp
temp$BestMarkets %>% as_tibble()
Markets$TopChoices %>% as_tibble()
Markets <- MultiCellMarketSelection(data = GeoTestData_PreTest,
k = 1,
sampling_method = "systematic",
# top_choices = 10,
N = c(2,3),
effect_size = seq(0, 0.25, 0.025),
treatment_periods = c(15),
lookback_window = 1,
cpic = c(1),
alpha = 0.1,
model = "None",
fixed_effects = TRUE,
Correlations = TRUE,
side_of_test = "one_sided")
Markets
MultiCellMarketSelection
identity(42)
identity(c(2,3,4,))
identity(c(2,3,4,5))
